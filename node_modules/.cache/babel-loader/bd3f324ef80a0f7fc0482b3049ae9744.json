{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VdxfUniValue = exports.VDXF_UNI_VALUE_VERSION_CURRENT = exports.VDXF_UNI_VALUE_VERSION_INVALID = void 0;\nconst varuint_1 = require(\"../utils/varuint\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst address_1 = require(\"../utils/address\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst bn_js_1 = require(\"bn.js\");\nconst vdxf_2 = require(\"../vdxf\");\nexports.VDXF_UNI_VALUE_VERSION_INVALID = new bn_js_1.BN(0, 10);\nexports.VDXF_UNI_VALUE_VERSION_CURRENT = new bn_js_1.BN(1, 10);\nconst {\n  BufferWriter,\n  BufferReader\n} = bufferutils_1.default;\n// This UniValue class was adapted from C++ code for encoding JSON objects into bytes. It is not serialization and\n// therefore doesn't have a fromBuffer function, as you can't reliably decode it, only encode.\nclass VdxfUniValue {\n  constructor(data) {\n    if (data === null || data === void 0 ? void 0 : data.values) this.values = data.values;\n    if (data === null || data === void 0 ? void 0 : data.version) this.version = data.version;else this.version = exports.VDXF_UNI_VALUE_VERSION_CURRENT;\n  }\n  getByteLength() {\n    let length = 0;\n    for (const key of this.values.keys()) {\n      const value = this.values.get(key);\n      if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n        length += vdxf_1.HASH160_BYTE_LENGTH;\n        length += 1; // varint length 1\n        length += 2; // ss type + ver (lengths)\n        length += varuint_1.default.encodingLength(value.length);\n        length += value.length;\n      } else throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n    }\n    return length;\n  }\n  toBuffer() {\n    const writer = new BufferWriter(Buffer.alloc(this.getByteLength()));\n    for (const key of this.values.keys()) {\n      const value = this.values.get(key);\n      writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n      writer.writeVarInt(this.version);\n      if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n        const valueString = value;\n        writer.writeVarInt(new bn_js_1.BN(Buffer.from(valueString, 'utf8').length + 3)); //NOTE 3 is from ss type + ver + vdxfidver \n        writer.writeVarSlice(Buffer.from(valueString, 'utf8'));\n      } else throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n    }\n    return writer.buffer;\n  }\n  fromBuffer(buffer, offset = 0, keylist = []) {\n    const reader = new BufferReader(buffer, offset);\n    let lastPrereadOffset = reader.offset;\n    function readNextKey() {\n      lastPrereadOffset = reader.offset;\n      try {\n        return (0, address_1.toBase58Check)(reader.readSlice(20), vdxf_1.I_ADDR_VERSION);\n      } catch (e) {\n        return null;\n      }\n    }\n    this.values = new Map();\n    for (const key of keylist) {\n      const dataTypeKey = readNextKey();\n      this.version = reader.readVarInt();\n      if (this.version.gt(exports.VDXF_UNI_VALUE_VERSION_CURRENT)) throw new Error(\"Unknown VDXFUniValue version\");\n      if (dataTypeKey == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n        reader.readVarInt();\n        this.values.set(dataTypeKey, reader.readVarSlice().toString('utf8'));\n      } else {\n        throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n      }\n    }\n    return reader.offset;\n  }\n  static fromJson(obj) {\n    const map = new Map();\n    for (const key in obj) {\n      map.set(key, obj[key]);\n    }\n    return new VdxfUniValue({\n      values: map\n    });\n  }\n  toJson() {\n    const ret = {};\n    for (const key of this.values.keys()) {\n      ret[key] = this.values.get(key);\n    }\n    return ret;\n  }\n}\nexports.VdxfUniValue = VdxfUniValue;","map":{"version":3,"names":["Object","defineProperty","exports","value","VdxfUniValue","VDXF_UNI_VALUE_VERSION_CURRENT","VDXF_UNI_VALUE_VERSION_INVALID","varuint_1","require","bufferutils_1","address_1","vdxf_1","bn_js_1","vdxf_2","BN","BufferWriter","BufferReader","default","constructor","data","values","version","getByteLength","length","key","keys","get","DATA_TYPE_STRING","vdxfid","HASH160_BYTE_LENGTH","encodingLength","Error","toBuffer","writer","Buffer","alloc","writeSlice","fromBase58Check","hash","writeVarInt","valueString","from","writeVarSlice","buffer","fromBuffer","offset","keylist","reader","lastPrereadOffset","readNextKey","toBase58Check","readSlice","I_ADDR_VERSION","e","Map","dataTypeKey","readVarInt","gt","set","readVarSlice","toString","fromJson","obj","map","toJson","ret"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/verus-typescript-primitives/dist/pbaas/VdxfUniValue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VdxfUniValue = exports.VDXF_UNI_VALUE_VERSION_CURRENT = exports.VDXF_UNI_VALUE_VERSION_INVALID = void 0;\nconst varuint_1 = require(\"../utils/varuint\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst address_1 = require(\"../utils/address\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst bn_js_1 = require(\"bn.js\");\nconst vdxf_2 = require(\"../vdxf\");\nexports.VDXF_UNI_VALUE_VERSION_INVALID = new bn_js_1.BN(0, 10);\nexports.VDXF_UNI_VALUE_VERSION_CURRENT = new bn_js_1.BN(1, 10);\nconst { BufferWriter, BufferReader } = bufferutils_1.default;\n// This UniValue class was adapted from C++ code for encoding JSON objects into bytes. It is not serialization and\n// therefore doesn't have a fromBuffer function, as you can't reliably decode it, only encode.\nclass VdxfUniValue {\n    constructor(data) {\n        if (data === null || data === void 0 ? void 0 : data.values)\n            this.values = data.values;\n        if (data === null || data === void 0 ? void 0 : data.version)\n            this.version = data.version;\n        else\n            this.version = exports.VDXF_UNI_VALUE_VERSION_CURRENT;\n    }\n    getByteLength() {\n        let length = 0;\n        for (const key of this.values.keys()) {\n            const value = this.values.get(key);\n            if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n                length += vdxf_1.HASH160_BYTE_LENGTH;\n                length += 1; // varint length 1\n                length += 2; // ss type + ver (lengths)\n                length += varuint_1.default.encodingLength(value.length);\n                length += value.length;\n            }\n            else\n                throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n        }\n        return length;\n    }\n    toBuffer() {\n        const writer = new BufferWriter(Buffer.alloc(this.getByteLength()));\n        for (const key of this.values.keys()) {\n            const value = this.values.get(key);\n            writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n            writer.writeVarInt(this.version);\n            if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n                const valueString = value;\n                writer.writeVarInt(new bn_js_1.BN(Buffer.from(valueString, 'utf8').length + 3)); //NOTE 3 is from ss type + ver + vdxfidver \n                writer.writeVarSlice(Buffer.from(valueString, 'utf8'));\n            }\n            else\n                throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n        }\n        return writer.buffer;\n    }\n    fromBuffer(buffer, offset = 0, keylist = []) {\n        const reader = new BufferReader(buffer, offset);\n        let lastPrereadOffset = reader.offset;\n        function readNextKey() {\n            lastPrereadOffset = reader.offset;\n            try {\n                return (0, address_1.toBase58Check)(reader.readSlice(20), vdxf_1.I_ADDR_VERSION);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        this.values = new Map();\n        for (const key of keylist) {\n            const dataTypeKey = readNextKey();\n            this.version = reader.readVarInt();\n            if (this.version.gt(exports.VDXF_UNI_VALUE_VERSION_CURRENT))\n                throw new Error(\"Unknown VDXFUniValue version\");\n            if (dataTypeKey == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n                reader.readVarInt();\n                this.values.set(dataTypeKey, reader.readVarSlice().toString('utf8'));\n            }\n            else {\n                throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n            }\n        }\n        return reader.offset;\n    }\n    static fromJson(obj) {\n        const map = new Map();\n        for (const key in obj) {\n            map.set(key, obj[key]);\n        }\n        return new VdxfUniValue({\n            values: map\n        });\n    }\n    toJson() {\n        const ret = {};\n        for (const key of this.values.keys()) {\n            ret[key] = this.values.get(key);\n        }\n        return ret;\n    }\n}\nexports.VdxfUniValue = VdxfUniValue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}