{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeSaplingAddress = exports.convertBits = exports.fromBech32 = void 0;\nconst bech32_1 = require(\"bech32\");\n// TODO: Fix this function, it doesn't decode sapling addrs\nconst fromBech32 = address => {\n  var result = bech32_1.bech32.decode(address);\n  var data = bech32_1.bech32.fromWords(result.words);\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n};\nexports.fromBech32 = fromBech32;\nconst convertBits = (data, from, to, strictMode) => {\n  const length = strictMode ? Math.floor(data.length * from / to) : Math.ceil(data.length * from / to);\n  const mask = (1 << to) - 1;\n  const result = Buffer.alloc(length);\n  let index = 0;\n  let accumulator = 0;\n  let bits = 0;\n  for (const value of data) {\n    accumulator = accumulator << from | value;\n    bits += from;\n    while (bits >= to) {\n      bits -= to;\n      result[index] = accumulator >> bits & mask;\n      ++index;\n    }\n  }\n  if (!strictMode) {\n    if (bits > 0) {\n      result[index] = accumulator << to - bits & mask;\n      ++index;\n    }\n  } else {\n    throw new Error(\"Bits cannot be converted\");\n  }\n  return result;\n};\nexports.convertBits = convertBits;\nconst decodeSaplingAddress = address => {\n  const result = (0, exports.fromBech32)(address);\n  const data = (0, exports.convertBits)(result.data, 5, 8, false);\n  return {\n    d: data.subarray(0, 10),\n    pk_d: data.subarray(10)\n  };\n};\nexports.decodeSaplingAddress = decodeSaplingAddress;","map":{"version":3,"names":["Object","defineProperty","exports","value","decodeSaplingAddress","convertBits","fromBech32","bech32_1","require","address","result","bech32","decode","data","fromWords","words","version","prefix","Buffer","from","to","strictMode","length","Math","floor","ceil","mask","alloc","index","accumulator","bits","Error","d","subarray","pk_d"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/node_modules/verus-typescript-primitives/dist/utils/sapling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeSaplingAddress = exports.convertBits = exports.fromBech32 = void 0;\nconst bech32_1 = require(\"bech32\");\n// TODO: Fix this function, it doesn't decode sapling addrs\nconst fromBech32 = (address) => {\n    var result = bech32_1.bech32.decode(address);\n    var data = bech32_1.bech32.fromWords(result.words);\n    return {\n        version: result.words[0],\n        prefix: result.prefix,\n        data: Buffer.from(data)\n    };\n};\nexports.fromBech32 = fromBech32;\nconst convertBits = (data, from, to, strictMode) => {\n    const length = strictMode\n        ? Math.floor((data.length * from) / to)\n        : Math.ceil((data.length * from) / to);\n    const mask = (1 << to) - 1;\n    const result = Buffer.alloc(length);\n    let index = 0;\n    let accumulator = 0;\n    let bits = 0;\n    for (const value of data) {\n        accumulator = (accumulator << from) | value;\n        bits += from;\n        while (bits >= to) {\n            bits -= to;\n            result[index] = (accumulator >> bits) & mask;\n            ++index;\n        }\n    }\n    if (!strictMode) {\n        if (bits > 0) {\n            result[index] = (accumulator << (to - bits)) & mask;\n            ++index;\n        }\n    }\n    else {\n        throw new Error(\"Bits cannot be converted\");\n    }\n    return result;\n};\nexports.convertBits = convertBits;\nconst decodeSaplingAddress = (address) => {\n    const result = (0, exports.fromBech32)(address);\n    const data = (0, exports.convertBits)(result.data, 5, 8, false);\n    return { d: data.subarray(0, 10), pk_d: data.subarray(10) };\n};\nexports.decodeSaplingAddress = decodeSaplingAddress;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAGF,OAAO,CAACG,WAAW,GAAGH,OAAO,CAACI,UAAU,GAAG,KAAK,CAAC;AAChF,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA,MAAMF,UAAU,GAAIG,OAAO,IAAK;EAC5B,IAAIC,MAAM,GAAGH,QAAQ,CAACI,MAAM,CAACC,MAAM,CAACH,OAAO,CAAC;EAC5C,IAAII,IAAI,GAAGN,QAAQ,CAACI,MAAM,CAACG,SAAS,CAACJ,MAAM,CAACK,KAAK,CAAC;EAClD,OAAO;IACHC,OAAO,EAAEN,MAAM,CAACK,KAAK,CAAC,CAAC,CAAC;IACxBE,MAAM,EAAEP,MAAM,CAACO,MAAM;IACrBJ,IAAI,EAAEK,MAAM,CAACC,IAAI,CAACN,IAAI;EAC1B,CAAC;AACL,CAAC;AACDX,OAAO,CAACI,UAAU,GAAGA,UAAU;AAC/B,MAAMD,WAAW,GAAGA,CAACQ,IAAI,EAAEM,IAAI,EAAEC,EAAE,EAAEC,UAAU,KAAK;EAChD,MAAMC,MAAM,GAAGD,UAAU,GACnBE,IAAI,CAACC,KAAK,CAAEX,IAAI,CAACS,MAAM,GAAGH,IAAI,GAAIC,EAAE,CAAC,GACrCG,IAAI,CAACE,IAAI,CAAEZ,IAAI,CAACS,MAAM,GAAGH,IAAI,GAAIC,EAAE,CAAC;EAC1C,MAAMM,IAAI,GAAG,CAAC,CAAC,IAAIN,EAAE,IAAI,CAAC;EAC1B,MAAMV,MAAM,GAAGQ,MAAM,CAACS,KAAK,CAACL,MAAM,CAAC;EACnC,IAAIM,KAAK,GAAG,CAAC;EACb,IAAIC,WAAW,GAAG,CAAC;EACnB,IAAIC,IAAI,GAAG,CAAC;EACZ,KAAK,MAAM3B,KAAK,IAAIU,IAAI,EAAE;IACtBgB,WAAW,GAAIA,WAAW,IAAIV,IAAI,GAAIhB,KAAK;IAC3C2B,IAAI,IAAIX,IAAI;IACZ,OAAOW,IAAI,IAAIV,EAAE,EAAE;MACfU,IAAI,IAAIV,EAAE;MACVV,MAAM,CAACkB,KAAK,CAAC,GAAIC,WAAW,IAAIC,IAAI,GAAIJ,IAAI;MAC5C,EAAEE,KAAK;IACX;EACJ;EACA,IAAI,CAACP,UAAU,EAAE;IACb,IAAIS,IAAI,GAAG,CAAC,EAAE;MACVpB,MAAM,CAACkB,KAAK,CAAC,GAAIC,WAAW,IAAKT,EAAE,GAAGU,IAAK,GAAIJ,IAAI;MACnD,EAAEE,KAAK;IACX;EACJ,CAAC,MACI;IACD,MAAM,IAAIG,KAAK,CAAC,0BAA0B,CAAC;EAC/C;EACA,OAAOrB,MAAM;AACjB,CAAC;AACDR,OAAO,CAACG,WAAW,GAAGA,WAAW;AACjC,MAAMD,oBAAoB,GAAIK,OAAO,IAAK;EACtC,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAER,OAAO,CAACI,UAAU,EAAEG,OAAO,CAAC;EAC/C,MAAMI,IAAI,GAAG,CAAC,CAAC,EAAEX,OAAO,CAACG,WAAW,EAAEK,MAAM,CAACG,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC;EAC/D,OAAO;IAAEmB,CAAC,EAAEnB,IAAI,CAACoB,QAAQ,CAAC,CAAC,EAAE,EAAE,CAAC;IAAEC,IAAI,EAAErB,IAAI,CAACoB,QAAQ,CAAC,EAAE;EAAE,CAAC;AAC/D,CAAC;AACD/B,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB","ignoreList":[]},"metadata":{},"sourceType":"script"}