{"ast":null,"code":"import { convertVerusAddressToEthAddress, fromBase58ToHex } from \"./convert\";\nimport { isiAddress, isRAddress, isETHAddress } from 'utils/rules';\nimport { GLOBAL_ADDRESS, BLOCKCHAIN_NAME } from \"constants/contractAddress\";\nimport { ETH_FEES } from 'constants/contractAddress';\n\n// Flags for CTransferDesination type\nexport const DEST_PKH = 2;\nexport const DEST_ID = 4;\nexport const DEST_ETH = 9;\nconst FLAG_DEST_AUX = 64;\nconst FLAG_DEST_GATEWAY = 128;\nconst VALID = 1;\nconst CONVERT = 2;\nconst PRECONVERT = 4;\nconst CROSS_SYSTEM = 0x40; // if this is set there is a systemID serialized and deserialized as well for destination\nconst IMPORT_TO_SOURCE = 0x200; // set when the source currency not destination is the import currency\nconst RESERVE_TO_RESERVE = 0x400; // for arbitrage or transient conversion 2 stage solving (2nd from new fractional to reserves)\nconst bounceBackFee = Buffer.alloc(8); //write LE bounce back fee \n\nexport const getConfigOptions = ({\n  address,\n  destination,\n  poolAvailable,\n  token,\n  GASPrice,\n  auxDest\n}) => {\n  let destinationtype = null;\n  let flagvalue = VALID;\n  let secondreserveid = \"0x0000000000000000000000000000000000000000\";\n  let destinationcurrency = null;\n  let destinationaddress = {};\n  //set destination to correct type\n  if (isiAddress(address)) {\n    destinationtype = DEST_ID; //ID TYPE \n    destinationaddress = convertVerusAddressToEthAddress(address);\n  } else if (isRAddress(address)) {\n    destinationtype = DEST_PKH; //R TYPE\n    destinationaddress = convertVerusAddressToEthAddress(address);\n  } else if (isETHAddress(address)) {\n    destinationtype = DEST_ETH + FLAG_DEST_AUX; //ETH TYPE\n    destinationaddress = `${address}01160214${convertVerusAddressToEthAddress(auxDest).slice(2)}`; // vec 01 , subvec length 0x16, type DEST_PKH length 0x14\n  }\n  if (destinationtype === DEST_ID || destinationtype === DEST_PKH) {\n    //if I or R address chosen then do one way specific stuff          \n    if (!poolAvailable) {\n      // pool not available\n      if (destination === BLOCKCHAIN_NAME) {\n        flagvalue = VALID;\n        destinationcurrency = GLOBAL_ADDRESS.VRSC;\n      } else {\n        alert(\"Cannot convert yet Bridge.veth not launched\"); //add in FLAGS logic for destination    \n        return null;\n      }\n    } else {\n      if (destination === BLOCKCHAIN_NAME) {\n        destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open all sends go to bridge.veth         \n        flagvalue = VALID;\n      } else if (destination === 'bridgeDAI') {\n        if (token.value !== GLOBAL_ADDRESS.DAI && token.value !== GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open convert from token  to DAI \n          secondreserveid = GLOBAL_ADDRESS.DAI;\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE; //add convert flag on\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.DAI;\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n        } else {\n          alert(`Cannot convert DAI to DAI. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\n          return null;\n        }\n      } else if (destination === 'bridgeVRSC') {\n        if (token.value !== GLOBAL_ADDRESS.VRSC && token.value !== GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open convert from token to VRSC\n          secondreserveid = GLOBAL_ADDRESS.VRSC;\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE; //add convert flag on\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.VRSC;\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n        } else {\n          alert(`Cannot convert ${BLOCKCHAIN_NAME} to ${BLOCKCHAIN_NAME}. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\n          return null;\n        }\n      } else if (destination === 'bridgeETH') {\n        if (token.value !== GLOBAL_ADDRESS.ETH && token.value !== GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open convert from token to ETH\n          secondreserveid = GLOBAL_ADDRESS.ETH;\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE; //add convert flag on\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.ETH;\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n        } else {\n          alert(`Cannot convert ETH to ETH. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\n          return null;\n        }\n      } else if (destination === 'bridgeMKR') {\n        if (token.value !== GLOBAL_ADDRESS.MKR && token.value !== GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open convert from token to ETH\n          secondreserveid = GLOBAL_ADDRESS.MKR;\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE; //add convert flag on\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.MKR;\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n        } else {\n          alert(`Cannot convert MKR to MKR. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\n          return null;\n        }\n      } else if (destination === `bridge${BLOCKCHAIN_NAME.toUpperCase()}`) {\n        if (token.value !== GLOBAL_ADDRESS.VRSC && token.value !== GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open convert from token to ETH\n          secondreserveid = GLOBAL_ADDRESS.VRSC;\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE; //add convert flag on\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\n          destinationcurrency = GLOBAL_ADDRESS.VRSC;\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n        } else {\n          alert(`Cannot convert ${BLOCKCHAIN_NAME} to ${BLOCKCHAIN_NAME}. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\n          return null;\n        }\n      } else if (destination === 'bridgeBRIDGE') {\n        destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open all sends go to bridge.veth\n        if (token.value !== GLOBAL_ADDRESS.BETH) {\n          flagvalue = VALID + CONVERT; //add convert flag on\n        } else {\n          alert(`Cannot convert bridge to bridge. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\n          return null;\n        }\n      } else {\n        alert(\"Cannot bounce back, direct send only with i or R address\"); //add in FLAGS logic for destination\n        return null;\n      }\n    }\n  } else if (destinationtype === DEST_ETH + FLAG_DEST_AUX && poolAvailable && token.value !== GLOBAL_ADDRESS.BETH && GASPrice) {\n    // if ethereuem address and pool is available \n    destinationcurrency = GLOBAL_ADDRESS.BETH;\n    destinationtype += FLAG_DEST_GATEWAY; //add 128 = FLAG_DEST_GATEWAY\n\n    bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);\n    //destination is concatenated with the gateway back address (bridge.veth) + uint160() + 0.003 ETH in fees uint64LE\n    destinationaddress = destinationaddress.slice(0, 42) + GLOBAL_ADDRESS.ETH.slice(2) + \"0000000000000000000000000000000000000000\" + bounceBackFee.toString('hex') + destinationaddress.slice(42);\n    if (destination === \"swaptoVRSC\") {\n      secondreserveid = GLOBAL_ADDRESS.VRSC;\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\n    }\n    if (destination === \"swaptoDAI\") {\n      secondreserveid = GLOBAL_ADDRESS.DAI;\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\n    }\n    if (destination === \"swaptoBRIDGE\") {\n      flagvalue = VALID + CONVERT;\n    }\n    if (destination === \"swaptoETH\") {\n      secondreserveid = GLOBAL_ADDRESS.ETH;\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\n    }\n    if (destination === \"swaptoMKR\") {\n      secondreserveid = GLOBAL_ADDRESS.MKR;\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\n    }\n  } else if (destinationtype === DEST_ETH + FLAG_DEST_AUX && poolAvailable && token.value === GLOBAL_ADDRESS.BETH && GASPrice) {\n    // if ethereuem address and pool is available \n    destinationtype += FLAG_DEST_GATEWAY;\n    bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);\n    //destination is concatenated with the gateway back address (vETH) + uint160() + 0.003 ETH in fees uint64LE\n    destinationaddress = destinationaddress.slice(0, 42) + GLOBAL_ADDRESS.ETH.slice(2) + \"0000000000000000000000000000000000000000\" + bounceBackFee.toString('hex') + destinationaddress.slice(42);\n    if (destination === \"swaptoVRSC\") {\n      destinationcurrency = GLOBAL_ADDRESS.VRSC;\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n    }\n    if (destination === \"swaptoDAI\") {\n      destinationcurrency = GLOBAL_ADDRESS.DAI;\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n    }\n    if (destination === \"swaptoETH\") {\n      destinationcurrency = GLOBAL_ADDRESS.ETH;\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n    }\n    if (destination === \"swaptoMKR\") {\n      destinationcurrency = GLOBAL_ADDRESS.MKR;\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\n    }\n  } else {\n    alert(\"Bridge.veth not launched yet, send only direct to i or R until launch complete\"); //add in FLAGS logic for destination\n    return null;\n  }\n  let feecurrency = {};\n  let fees = {};\n  if (poolAvailable) {\n    feecurrency = GLOBAL_ADDRESS.ETH;\n    fees = ETH_FEES.SATS; //0.003 ETH FEE\n  } else {\n    feecurrency = GLOBAL_ADDRESS.VRSC; //pre bridge launch fees must be set as vrsc\n    fees = 2000000; // 0.02 VRSC\n  }\n  return {\n    flagvalue,\n    feecurrency,\n    fees,\n    destinationtype,\n    destinationaddress,\n    destinationcurrency,\n    secondreserveid\n  };\n};","map":{"version":3,"names":["convertVerusAddressToEthAddress","fromBase58ToHex","isiAddress","isRAddress","isETHAddress","GLOBAL_ADDRESS","BLOCKCHAIN_NAME","ETH_FEES","DEST_PKH","DEST_ID","DEST_ETH","FLAG_DEST_AUX","FLAG_DEST_GATEWAY","VALID","CONVERT","PRECONVERT","CROSS_SYSTEM","IMPORT_TO_SOURCE","RESERVE_TO_RESERVE","bounceBackFee","Buffer","alloc","getConfigOptions","address","destination","poolAvailable","token","GASPrice","auxDest","destinationtype","flagvalue","secondreserveid","destinationcurrency","destinationaddress","slice","VRSC","alert","BETH","value","DAI","ETH","MKR","toUpperCase","writeUInt32LE","SATSCOST","toString","feecurrency","fees","SATS"],"sources":["/Users/oddfl3x/Code/bridge/natiBridgeWebsite - Copy/src/utils/txConfig.js"],"sourcesContent":["import { convertVerusAddressToEthAddress, fromBase58ToHex } from \"./convert\";\r\nimport { isiAddress, isRAddress, isETHAddress } from 'utils/rules';\r\nimport { GLOBAL_ADDRESS, BLOCKCHAIN_NAME } from \"constants/contractAddress\";\r\nimport { ETH_FEES } from 'constants/contractAddress';\r\n\r\n// Flags for CTransferDesination type\r\nexport const DEST_PKH = 2\r\nexport const DEST_ID = 4\r\nexport const DEST_ETH = 9\r\nconst FLAG_DEST_AUX = 64\r\nconst FLAG_DEST_GATEWAY = 128\r\n\r\nconst VALID = 1\r\nconst CONVERT = 2\r\nconst PRECONVERT = 4\r\nconst CROSS_SYSTEM = 0x40                // if this is set there is a systemID serialized and deserialized as well for destination\r\nconst IMPORT_TO_SOURCE = 0x200           // set when the source currency not destination is the import currency\r\nconst RESERVE_TO_RESERVE = 0x400         // for arbitrage or transient conversion 2 stage solving (2nd from new fractional to reserves)\r\nconst bounceBackFee = Buffer.alloc(8); //write LE bounce back fee \r\n\r\nexport const getConfigOptions = ({ address, destination, poolAvailable, token, GASPrice, auxDest }) => {\r\n  let destinationtype = null;\r\n  let flagvalue = VALID;\r\n  let secondreserveid = \"0x0000000000000000000000000000000000000000\"\r\n  let destinationcurrency = null;\r\n\r\n  let destinationaddress = {};\r\n  //set destination to correct type\r\n  if (isiAddress(address)) {\r\n    destinationtype = DEST_ID; //ID TYPE \r\n    destinationaddress = convertVerusAddressToEthAddress(address)\r\n  } else if (isRAddress(address)) {\r\n    destinationtype = DEST_PKH; //R TYPE\r\n    destinationaddress = convertVerusAddressToEthAddress(address)\r\n  } else if (isETHAddress(address)) {\r\n    destinationtype = DEST_ETH + FLAG_DEST_AUX; //ETH TYPE\r\n    destinationaddress = `${address}01160214${convertVerusAddressToEthAddress(auxDest).slice(2)}`; // vec 01 , subvec length 0x16, type DEST_PKH length 0x14\r\n  }\r\n\r\n  if (destinationtype === DEST_ID || destinationtype === DEST_PKH) { //if I or R address chosen then do one way specific stuff          \r\n    if (!poolAvailable) { // pool not available\r\n      if (destination === BLOCKCHAIN_NAME) {\r\n        flagvalue = VALID;\r\n        destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n      } else {\r\n        alert(\"Cannot convert yet Bridge.veth not launched\"); //add in FLAGS logic for destination    \r\n        return null;\r\n      }\r\n    } else {\r\n      if (destination === BLOCKCHAIN_NAME) {\r\n        destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open all sends go to bridge.veth         \r\n        flagvalue = VALID;\r\n      } else if (destination === 'bridgeDAI') {\r\n        if (token.value !== GLOBAL_ADDRESS.DAI && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token  to DAI \r\n          secondreserveid = GLOBAL_ADDRESS.DAI;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.DAI;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert DAI to DAI. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === 'bridgeVRSC') {\r\n        if (token.value !== GLOBAL_ADDRESS.VRSC && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to VRSC\r\n          secondreserveid = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert ${BLOCKCHAIN_NAME} to ${BLOCKCHAIN_NAME}. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === 'bridgeETH') {\r\n        if (token.value !== GLOBAL_ADDRESS.ETH && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to ETH\r\n          secondreserveid = GLOBAL_ADDRESS.ETH;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.ETH;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert ETH to ETH. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === 'bridgeMKR') {\r\n        if (token.value !== GLOBAL_ADDRESS.MKR && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to ETH\r\n          secondreserveid = GLOBAL_ADDRESS.MKR;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.MKR;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert MKR to MKR. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === `bridge${BLOCKCHAIN_NAME.toUpperCase()}`) {\r\n        if (token.value !== GLOBAL_ADDRESS.VRSC && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to ETH\r\n          secondreserveid = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert ${BLOCKCHAIN_NAME} to ${BLOCKCHAIN_NAME}. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      }\r\n      else if (destination === 'bridgeBRIDGE') {\r\n\r\n        destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open all sends go to bridge.veth\r\n        if (token.value !== GLOBAL_ADDRESS.BETH) {\r\n          flagvalue = VALID + CONVERT;   //add convert flag on\r\n        } else {\r\n          alert(`Cannot convert bridge to bridge. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else {\r\n        alert(\"Cannot bounce back, direct send only with i or R address\"); //add in FLAGS logic for destination\r\n        return null;\r\n      }\r\n    }\r\n  } else if (\r\n    destinationtype === DEST_ETH + FLAG_DEST_AUX\r\n    && poolAvailable\r\n    && token.value !== GLOBAL_ADDRESS.BETH\r\n    && GASPrice\r\n  ) {  // if ethereuem address and pool is available \r\n    destinationcurrency = GLOBAL_ADDRESS.BETH;\r\n    destinationtype += FLAG_DEST_GATEWAY; //add 128 = FLAG_DEST_GATEWAY\r\n\r\n    bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);\r\n    //destination is concatenated with the gateway back address (bridge.veth) + uint160() + 0.003 ETH in fees uint64LE\r\n    destinationaddress = destinationaddress.slice(0, 42) + GLOBAL_ADDRESS.ETH.slice(2) + \"0000000000000000000000000000000000000000\" + bounceBackFee.toString('hex') + destinationaddress.slice(42);\r\n\r\n    if (destination === \"swaptoVRSC\") {\r\n      secondreserveid = GLOBAL_ADDRESS.VRSC;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n    if (destination === \"swaptoDAI\") {\r\n      secondreserveid = GLOBAL_ADDRESS.DAI;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n    if (destination === \"swaptoBRIDGE\") {\r\n      flagvalue = VALID + CONVERT;\r\n    }\r\n    if (destination === \"swaptoETH\") {\r\n      secondreserveid = GLOBAL_ADDRESS.ETH;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n    if (destination === \"swaptoMKR\") {\r\n      secondreserveid = GLOBAL_ADDRESS.MKR;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n\r\n\r\n  } else if (\r\n    destinationtype === DEST_ETH + FLAG_DEST_AUX\r\n    && poolAvailable\r\n    && token.value === GLOBAL_ADDRESS.BETH\r\n    && GASPrice\r\n  ) {  // if ethereuem address and pool is available \r\n    destinationtype += FLAG_DEST_GATEWAY;\r\n\r\n    bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);\r\n    //destination is concatenated with the gateway back address (vETH) + uint160() + 0.003 ETH in fees uint64LE\r\n    destinationaddress = destinationaddress.slice(0, 42) + GLOBAL_ADDRESS.ETH.slice(2) + \"0000000000000000000000000000000000000000\" + bounceBackFee.toString('hex') + destinationaddress.slice(42);\r\n\r\n    if (destination === \"swaptoVRSC\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n    if (destination === \"swaptoDAI\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.DAI;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n    if (destination === \"swaptoETH\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.ETH;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n    if (destination === \"swaptoMKR\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.MKR;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n\r\n  } else {\r\n    alert(\"Bridge.veth not launched yet, send only direct to i or R until launch complete\"); //add in FLAGS logic for destination\r\n    return null;\r\n  }\r\n\r\n  let feecurrency = {};\r\n  let fees = {};\r\n  if (poolAvailable) {\r\n    feecurrency = GLOBAL_ADDRESS.ETH;\r\n    fees = ETH_FEES.SATS; //0.003 ETH FEE\r\n  } else {\r\n    feecurrency = GLOBAL_ADDRESS.VRSC; //pre bridge launch fees must be set as vrsc\r\n    fees = 2000000  // 0.02 VRSC\r\n  }\r\n\r\n  return { flagvalue, feecurrency, fees, destinationtype, destinationaddress, destinationcurrency, secondreserveid }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}