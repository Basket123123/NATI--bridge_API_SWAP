{"ast":null,"code":"import{convertVerusAddressToEthAddress,fromBase58ToHex}from\"./convert\";import{isiAddress,isRAddress,isETHAddress}from'utils/rules';import{GLOBAL_ADDRESS,BLOCKCHAIN_NAME}from\"constants/contractAddress\";import{ETH_FEES}from'constants/contractAddress';// Flags for CTransferDesination type\nexport const DEST_PKH=2;export const DEST_ID=4;export const DEST_ETH=9;const FLAG_DEST_AUX=64;const FLAG_DEST_GATEWAY=128;const VALID=1;const CONVERT=2;const PRECONVERT=4;const CROSS_SYSTEM=0x40;// if this is set there is a systemID serialized and deserialized as well for destination\nconst IMPORT_TO_SOURCE=0x200;// set when the source currency not destination is the import currency\nconst RESERVE_TO_RESERVE=0x400;// for arbitrage or transient conversion 2 stage solving (2nd from new fractional to reserves)\nconst bounceBackFee=Buffer.alloc(8);//write LE bounce back fee \nexport const getConfigOptions=_ref=>{let{address,destination,poolAvailable,token,GASPrice,auxDest}=_ref;let destinationtype=null;let flagvalue=VALID;let secondreserveid=\"0x0000000000000000000000000000000000000000\";let destinationcurrency=null;let destinationaddress={};//set destination to correct type\nif(isiAddress(address)){destinationtype=DEST_ID;//ID TYPE \ndestinationaddress=convertVerusAddressToEthAddress(address);}else if(isRAddress(address)){destinationtype=DEST_PKH;//R TYPE\ndestinationaddress=convertVerusAddressToEthAddress(address);}else if(isETHAddress(address)){destinationtype=DEST_ETH+FLAG_DEST_AUX;//ETH TYPE\ndestinationaddress=\"\".concat(address,\"01160214\").concat(convertVerusAddressToEthAddress(auxDest).slice(2));// vec 01 , subvec length 0x16, type DEST_PKH length 0x14\n}if(destinationtype===DEST_ID||destinationtype===DEST_PKH){//if I or R address chosen then do one way specific stuff          \nif(!poolAvailable){// pool not available\nif(destination===BLOCKCHAIN_NAME){flagvalue=VALID;destinationcurrency=GLOBAL_ADDRESS.VRSC;}else{alert(\"Cannot convert yet Bridge.veth not launched\");//add in FLAGS logic for destination    \nreturn null;}}else{if(destination===BLOCKCHAIN_NAME){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open all sends go to bridge.veth         \nflagvalue=VALID;}else if(destination==='bridgeDAI'){if(token.value!==GLOBAL_ADDRESS.DAI&&token.value!==GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open convert from token  to DAI \nsecondreserveid=GLOBAL_ADDRESS.DAI;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;//add convert flag on\n}else if(token.value===GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.DAI;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}else{alert(\"Cannot convert DAI to DAI. Send Direct to \".concat(BLOCKCHAIN_NAME));//add in FLAGS logic for destination\nreturn null;}}else if(destination==='bridgeVRSC'){if(token.value!==GLOBAL_ADDRESS.VRSC&&token.value!==GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open convert from token to VRSC\nsecondreserveid=GLOBAL_ADDRESS.VRSC;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;//add convert flag on\n}else if(token.value===GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.VRSC;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}else{alert(\"Cannot convert \".concat(BLOCKCHAIN_NAME,\" to \").concat(BLOCKCHAIN_NAME,\". Send Direct to \").concat(BLOCKCHAIN_NAME));//add in FLAGS logic for destination\nreturn null;}}else if(destination==='bridgeETH'){if(token.value!==GLOBAL_ADDRESS.ETH&&token.value!==GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open convert from token to ETH\nsecondreserveid=GLOBAL_ADDRESS.ETH;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;//add convert flag on\n}else if(token.value===GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.ETH;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}else{alert(\"Cannot convert ETH to ETH. Send Direct to \".concat(BLOCKCHAIN_NAME));//add in FLAGS logic for destination\nreturn null;}}else if(destination==='bridgeMKR'){if(token.value!==GLOBAL_ADDRESS.MKR&&token.value!==GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open convert from token to ETH\nsecondreserveid=GLOBAL_ADDRESS.MKR;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;//add convert flag on\n}else if(token.value===GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.MKR;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}else{alert(\"Cannot convert MKR to MKR. Send Direct to \".concat(BLOCKCHAIN_NAME));//add in FLAGS logic for destination\nreturn null;}}else if(destination===\"bridge\".concat(BLOCKCHAIN_NAME.toUpperCase())){if(token.value!==GLOBAL_ADDRESS.VRSC&&token.value!==GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open convert from token to ETH\nsecondreserveid=GLOBAL_ADDRESS.VRSC;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;//add convert flag on\n}else if(token.value===GLOBAL_ADDRESS.BETH){destinationcurrency=GLOBAL_ADDRESS.VRSC;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}else{alert(\"Cannot convert \".concat(BLOCKCHAIN_NAME,\" to \").concat(BLOCKCHAIN_NAME,\". Send Direct to \").concat(BLOCKCHAIN_NAME));//add in FLAGS logic for destination\nreturn null;}}else if(destination==='bridgeBRIDGE'){destinationcurrency=GLOBAL_ADDRESS.BETH;//bridge open all sends go to bridge.veth\nif(token.value!==GLOBAL_ADDRESS.BETH){flagvalue=VALID+CONVERT;//add convert flag on\n}else{alert(\"Cannot convert bridge to bridge. Send Direct to \".concat(BLOCKCHAIN_NAME));//add in FLAGS logic for destination\nreturn null;}}else{alert(\"Cannot bounce back, direct send only with i or R address\");//add in FLAGS logic for destination\nreturn null;}}}else if(destinationtype===DEST_ETH+FLAG_DEST_AUX&&poolAvailable&&token.value!==GLOBAL_ADDRESS.BETH&&GASPrice){// if ethereuem address and pool is available \ndestinationcurrency=GLOBAL_ADDRESS.BETH;destinationtype+=FLAG_DEST_GATEWAY;//add 128 = FLAG_DEST_GATEWAY\nbounceBackFee.writeUInt32LE(GASPrice.SATSCOST);//destination is concatenated with the gateway back address (bridge.veth) + uint160() + 0.003 ETH in fees uint64LE\ndestinationaddress=destinationaddress.slice(0,42)+GLOBAL_ADDRESS.ETH.slice(2)+\"0000000000000000000000000000000000000000\"+bounceBackFee.toString('hex')+destinationaddress.slice(42);if(destination===\"swaptoVRSC\"){secondreserveid=GLOBAL_ADDRESS.VRSC;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;}if(destination===\"swaptoDAI\"){secondreserveid=GLOBAL_ADDRESS.DAI;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;}if(destination===\"swaptoBRIDGE\"){flagvalue=VALID+CONVERT;}if(destination===\"swaptoETH\"){secondreserveid=GLOBAL_ADDRESS.ETH;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;}if(destination===\"swaptoMKR\"){secondreserveid=GLOBAL_ADDRESS.MKR;flagvalue=VALID+CONVERT+RESERVE_TO_RESERVE;}}else if(destinationtype===DEST_ETH+FLAG_DEST_AUX&&poolAvailable&&token.value===GLOBAL_ADDRESS.BETH&&GASPrice){// if ethereuem address and pool is available \ndestinationtype+=FLAG_DEST_GATEWAY;bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);//destination is concatenated with the gateway back address (vETH) + uint160() + 0.003 ETH in fees uint64LE\ndestinationaddress=destinationaddress.slice(0,42)+GLOBAL_ADDRESS.ETH.slice(2)+\"0000000000000000000000000000000000000000\"+bounceBackFee.toString('hex')+destinationaddress.slice(42);if(destination===\"swaptoVRSC\"){destinationcurrency=GLOBAL_ADDRESS.VRSC;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}if(destination===\"swaptoDAI\"){destinationcurrency=GLOBAL_ADDRESS.DAI;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}if(destination===\"swaptoETH\"){destinationcurrency=GLOBAL_ADDRESS.ETH;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}if(destination===\"swaptoMKR\"){destinationcurrency=GLOBAL_ADDRESS.MKR;flagvalue=VALID+CONVERT+IMPORT_TO_SOURCE;}}else{alert(\"Bridge.veth not launched yet, send only direct to i or R until launch complete\");//add in FLAGS logic for destination\nreturn null;}let feecurrency={};let fees={};if(poolAvailable){feecurrency=GLOBAL_ADDRESS.ETH;fees=ETH_FEES.SATS;//0.003 ETH FEE\n}else{feecurrency=GLOBAL_ADDRESS.VRSC;//pre bridge launch fees must be set as vrsc\nfees=2000000;// 0.02 VRSC\n}return{flagvalue,feecurrency,fees,destinationtype,destinationaddress,destinationcurrency,secondreserveid};};","map":{"version":3,"names":["convertVerusAddressToEthAddress","fromBase58ToHex","isiAddress","isRAddress","isETHAddress","GLOBAL_ADDRESS","BLOCKCHAIN_NAME","ETH_FEES","DEST_PKH","DEST_ID","DEST_ETH","FLAG_DEST_AUX","FLAG_DEST_GATEWAY","VALID","CONVERT","PRECONVERT","CROSS_SYSTEM","IMPORT_TO_SOURCE","RESERVE_TO_RESERVE","bounceBackFee","Buffer","alloc","getConfigOptions","_ref","address","destination","poolAvailable","token","GASPrice","auxDest","destinationtype","flagvalue","secondreserveid","destinationcurrency","destinationaddress","concat","slice","VRSC","alert","BETH","value","DAI","ETH","MKR","toUpperCase","writeUInt32LE","SATSCOST","toString","feecurrency","fees","SATS"],"sources":["/Users/oddfl3x/Code/bridge2/NATI<>bridge_API_SWAP/src/utils/txConfig.js"],"sourcesContent":["import { convertVerusAddressToEthAddress, fromBase58ToHex } from \"./convert\";\r\nimport { isiAddress, isRAddress, isETHAddress } from 'utils/rules';\r\nimport { GLOBAL_ADDRESS, BLOCKCHAIN_NAME } from \"constants/contractAddress\";\r\nimport { ETH_FEES } from 'constants/contractAddress';\r\n\r\n// Flags for CTransferDesination type\r\nexport const DEST_PKH = 2\r\nexport const DEST_ID = 4\r\nexport const DEST_ETH = 9\r\nconst FLAG_DEST_AUX = 64\r\nconst FLAG_DEST_GATEWAY = 128\r\n\r\nconst VALID = 1\r\nconst CONVERT = 2\r\nconst PRECONVERT = 4\r\nconst CROSS_SYSTEM = 0x40                // if this is set there is a systemID serialized and deserialized as well for destination\r\nconst IMPORT_TO_SOURCE = 0x200           // set when the source currency not destination is the import currency\r\nconst RESERVE_TO_RESERVE = 0x400         // for arbitrage or transient conversion 2 stage solving (2nd from new fractional to reserves)\r\nconst bounceBackFee = Buffer.alloc(8); //write LE bounce back fee \r\n\r\nexport const getConfigOptions = ({ address, destination, poolAvailable, token, GASPrice, auxDest }) => {\r\n  let destinationtype = null;\r\n  let flagvalue = VALID;\r\n  let secondreserveid = \"0x0000000000000000000000000000000000000000\"\r\n  let destinationcurrency = null;\r\n\r\n  let destinationaddress = {};\r\n  //set destination to correct type\r\n  if (isiAddress(address)) {\r\n    destinationtype = DEST_ID; //ID TYPE \r\n    destinationaddress = convertVerusAddressToEthAddress(address)\r\n  } else if (isRAddress(address)) {\r\n    destinationtype = DEST_PKH; //R TYPE\r\n    destinationaddress = convertVerusAddressToEthAddress(address)\r\n  } else if (isETHAddress(address)) {\r\n    destinationtype = DEST_ETH + FLAG_DEST_AUX; //ETH TYPE\r\n    destinationaddress = `${address}01160214${convertVerusAddressToEthAddress(auxDest).slice(2)}`; // vec 01 , subvec length 0x16, type DEST_PKH length 0x14\r\n  }\r\n\r\n  if (destinationtype === DEST_ID || destinationtype === DEST_PKH) { //if I or R address chosen then do one way specific stuff          \r\n    if (!poolAvailable) { // pool not available\r\n      if (destination === BLOCKCHAIN_NAME) {\r\n        flagvalue = VALID;\r\n        destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n      } else {\r\n        alert(\"Cannot convert yet Bridge.veth not launched\"); //add in FLAGS logic for destination    \r\n        return null;\r\n      }\r\n    } else {\r\n      if (destination === BLOCKCHAIN_NAME) {\r\n        destinationcurrency = GLOBAL_ADDRESS.BETH; //bridge open all sends go to bridge.veth         \r\n        flagvalue = VALID;\r\n      } else if (destination === 'bridgeDAI') {\r\n        if (token.value !== GLOBAL_ADDRESS.DAI && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token  to DAI \r\n          secondreserveid = GLOBAL_ADDRESS.DAI;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.DAI;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert DAI to DAI. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === 'bridgeVRSC') {\r\n        if (token.value !== GLOBAL_ADDRESS.VRSC && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to VRSC\r\n          secondreserveid = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert ${BLOCKCHAIN_NAME} to ${BLOCKCHAIN_NAME}. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === 'bridgeETH') {\r\n        if (token.value !== GLOBAL_ADDRESS.ETH && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to ETH\r\n          secondreserveid = GLOBAL_ADDRESS.ETH;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.ETH;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert ETH to ETH. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === 'bridgeMKR') {\r\n        if (token.value !== GLOBAL_ADDRESS.MKR && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to ETH\r\n          secondreserveid = GLOBAL_ADDRESS.MKR;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.MKR;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert MKR to MKR. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else if (destination === `bridge${BLOCKCHAIN_NAME.toUpperCase()}`) {\r\n        if (token.value !== GLOBAL_ADDRESS.VRSC && token.value !== GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open convert from token to ETH\r\n          secondreserveid = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;   //add convert flag on\r\n        } else if (token.value === GLOBAL_ADDRESS.BETH) {\r\n          destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n          flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n        } else {\r\n          alert(`Cannot convert ${BLOCKCHAIN_NAME} to ${BLOCKCHAIN_NAME}. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      }\r\n      else if (destination === 'bridgeBRIDGE') {\r\n\r\n        destinationcurrency = GLOBAL_ADDRESS.BETH;  //bridge open all sends go to bridge.veth\r\n        if (token.value !== GLOBAL_ADDRESS.BETH) {\r\n          flagvalue = VALID + CONVERT;   //add convert flag on\r\n        } else {\r\n          alert(`Cannot convert bridge to bridge. Send Direct to ${BLOCKCHAIN_NAME}`); //add in FLAGS logic for destination\r\n          return null;\r\n        }\r\n      } else {\r\n        alert(\"Cannot bounce back, direct send only with i or R address\"); //add in FLAGS logic for destination\r\n        return null;\r\n      }\r\n    }\r\n  } else if (\r\n    destinationtype === DEST_ETH + FLAG_DEST_AUX\r\n    && poolAvailable\r\n    && token.value !== GLOBAL_ADDRESS.BETH\r\n    && GASPrice\r\n  ) {  // if ethereuem address and pool is available \r\n    destinationcurrency = GLOBAL_ADDRESS.BETH;\r\n    destinationtype += FLAG_DEST_GATEWAY; //add 128 = FLAG_DEST_GATEWAY\r\n\r\n    bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);\r\n    //destination is concatenated with the gateway back address (bridge.veth) + uint160() + 0.003 ETH in fees uint64LE\r\n    destinationaddress = destinationaddress.slice(0, 42) + GLOBAL_ADDRESS.ETH.slice(2) + \"0000000000000000000000000000000000000000\" + bounceBackFee.toString('hex') + destinationaddress.slice(42);\r\n\r\n    if (destination === \"swaptoVRSC\") {\r\n      secondreserveid = GLOBAL_ADDRESS.VRSC;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n    if (destination === \"swaptoDAI\") {\r\n      secondreserveid = GLOBAL_ADDRESS.DAI;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n    if (destination === \"swaptoBRIDGE\") {\r\n      flagvalue = VALID + CONVERT;\r\n    }\r\n    if (destination === \"swaptoETH\") {\r\n      secondreserveid = GLOBAL_ADDRESS.ETH;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n    if (destination === \"swaptoMKR\") {\r\n      secondreserveid = GLOBAL_ADDRESS.MKR;\r\n      flagvalue = VALID + CONVERT + RESERVE_TO_RESERVE;\r\n    }\r\n\r\n\r\n  } else if (\r\n    destinationtype === DEST_ETH + FLAG_DEST_AUX\r\n    && poolAvailable\r\n    && token.value === GLOBAL_ADDRESS.BETH\r\n    && GASPrice\r\n  ) {  // if ethereuem address and pool is available \r\n    destinationtype += FLAG_DEST_GATEWAY;\r\n\r\n    bounceBackFee.writeUInt32LE(GASPrice.SATSCOST);\r\n    //destination is concatenated with the gateway back address (vETH) + uint160() + 0.003 ETH in fees uint64LE\r\n    destinationaddress = destinationaddress.slice(0, 42) + GLOBAL_ADDRESS.ETH.slice(2) + \"0000000000000000000000000000000000000000\" + bounceBackFee.toString('hex') + destinationaddress.slice(42);\r\n\r\n    if (destination === \"swaptoVRSC\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.VRSC;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n    if (destination === \"swaptoDAI\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.DAI;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n    if (destination === \"swaptoETH\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.ETH;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n    if (destination === \"swaptoMKR\") {\r\n      destinationcurrency = GLOBAL_ADDRESS.MKR;\r\n      flagvalue = VALID + CONVERT + IMPORT_TO_SOURCE;\r\n    }\r\n\r\n  } else {\r\n    alert(\"Bridge.veth not launched yet, send only direct to i or R until launch complete\"); //add in FLAGS logic for destination\r\n    return null;\r\n  }\r\n\r\n  let feecurrency = {};\r\n  let fees = {};\r\n  if (poolAvailable) {\r\n    feecurrency = GLOBAL_ADDRESS.ETH;\r\n    fees = ETH_FEES.SATS; //0.003 ETH FEE\r\n  } else {\r\n    feecurrency = GLOBAL_ADDRESS.VRSC; //pre bridge launch fees must be set as vrsc\r\n    fees = 2000000  // 0.02 VRSC\r\n  }\r\n\r\n  return { flagvalue, feecurrency, fees, destinationtype, destinationaddress, destinationcurrency, secondreserveid }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}